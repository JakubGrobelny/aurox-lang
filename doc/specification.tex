\documentclass[12pt]{article}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{syntax}

\setlength{\grammarindent}{5em}

\title{\huge
    \textbf{Aurox language specification}}
\author{\Large Jakub Grobelny}

\begin{document}

\maketitle

\section{Syntax}

Character classification:
\begin{itemize}
    \item <\textit{whitespace}> --- HT, LF, CR, SPACE
    \item <\textit{digit}> --- 0-9
    \item <\textit{lowercase}> --- underscore or any other lowercase Unicode 
        characters \footnote{
            All characters \texttt{X} which satisfy 
            \texttt{char\textunderscore type(X, lower) predicate in SWI Prolog}
            }
    \item <\textit{uppercase}> --- any uppercase Unicode characters \footnote{
        All characters \texttt{X} which satisfy
        \texttt{char\textunderscore type(X, upper) predicate in SWI Prolog}
        }
    \item <\textit{special}> --- '-', '+', '*', '/', '=', '>', '<', '.', '!', '@', '\%', '\^', '~', '\&', '\$', '|'
\end{itemize}

Any character sequence beginning with character \texttt{\#} ending with LF are 
\textit{comments}.

\begin{grammar}

<operator> ::= <special>
    \alt <special> <operator>

<keyword> ::= \textbf{let} | \textbf{in} | \textbf{if} | \textbf{and} 
    | \textbf{or} | \textbf{then}
    \alt \textbf{match} | \textbf{else} | \textbf{with} | \textbf{type} 
    | \textbf{import} \alt \textbf{define} | \textbf{_} | \textbf{defop} 
    | \textbf{end} | \textbf{case}

<identifier> ::= <lowercase> <alphanum>

<type name> ::= <uppercase> <alphanum>

<alphanum> ::= <alphanum char> <alphanum> | $\epsilon$

<alphanum char> ::= <lowercase> | \textbf{?} | <digit>

<integer> ::= <digit> | <digit> <integer>

<float> ::= <integer> . <digit sequence> <exponent> \textbf{e}
    \alt <integer> <expontent>

<digit sequence> ::= <digit> | <digit> <digit sequence>

<e> ::= \textbf{e} | \textbf{E}

<exponent> ::= <e> \textbf{-} <integer>
    \alt <e> <integer>

<boolean> ::= \textbf{false} | \textbf{true}

<string> ::= \textbf{\"} <char sequence> \textbf{\"} | \textbf{\"}\textbf{\"}

<char> ::= \textbf{\'} <character> \textbf{\'}

<char sequence> ::= <character> | <character> <char sequence>

<character> ::= Unicode
    | \textbf{\textbackslash\textbackslash}
    | \textbf{\textbackslash b}
    | \textbf{\textbackslash n}
    | \textbf{\textbackslash f}
    | \textbf{\textbackslash a}
    | \textbf{\textbackslash r}
    | \textbf{\textbackslash t}
    | \textbf{\textbackslash 0}
    | \textbf{\textbackslash \"}
    | \textbf{\textbackslash \'}

<program> ::= <operator declaration> <program>
    \alt <import> <program>
    \alt <expression sequence> <program>
    \alt <definition> <program>
    \alt $\epsilon$

<operator declaration> ::= \textbf{defop} <operator> <integer> <associativity>

<associativity> ::= \textbf{left} | \textbf{right} 
    | \textbf{none} | \textbf{prefix} | \textbf{postfix}

<import> ::= \textbf{import} <import list> \textbf{end}

<import list> ::= $\epsilon$ | <string> <import list>
    \alt <type name> <import list>

<definition> ::= \textbf{define} <function name> <formal parameters> 
    \textbf{:} \\<type> \textbf{=} <expression sequence> \textbf{end}

<function name> ::= <identifier> | \textbf{(} <operator> \textbf{)}

<formal parameters> ::= <variable name> <formal parameters> |  $\epsilon$

<variable name> ::= <identifier> | \textbf{_}

<type> ::= <function type> \alt <function type> \textbf{,} <tupe>

<function type> ::= <algebraic data type>
    \alt <function type> \textbf(->) <algebraic data type> 

<algebraic data type> ::= <type name> <atomic type sequence>
    \alt <atomic type>

<atomic type sequence> ::= <atomic type> <atomic type sequence> | $\epsilon$

<atomic type> ::= <identifier> | <type name>
    \alt \textbf{[} <type> \textbf{]} | \textbf{(} <type> \textbf{)}

<type definition> ::= \textbf{type} <type name> <formal parameters> \textbf{with}\\
    <type constructors> \textbf{end}

<type constructors> ::= \textbf{case} <type name> <atomic type>
    \alt \textbf{case} <type name>

<expression sequence> ::= <expression>
    \alt <expression> \textbf{;} <expression sequence>

<expression> ::= <pattern matching> | <let definition> 
    \alt <conditional expression> | <tuple expression>

<let definition> ::= \textbf{let} <variable name> \textbf{:} <type> \textbf{=}\\
    <expression sequence> \textbf{in} <expression sequence> \textbf{end}

<conditional expression> ::= \textbf{if} <expression sequence> \textbf{then} \\
    <expression sequence> \textbf {else} <expression sequence> \textbf{end}

<pattern matching> ::= \textbf{match} <expression sequence> \textbf{with} \\
    <pattern matching cases> \textbf{end}

<pattern matching cases> ::= <pattern case> <pattern matching cases>
    \alt $\epsilon$

<pattern case> ::= \textbf{case} <pattern> \textbf{=>} <expression sequence>

<pattern> ::= <deconstructor pattern>
    \alt <deconstructor pattern> \textbf{,} <pattern>

<deconstructor pattern> ::= <type name> <atomic pattern>
    \alt <atomic pattern>

<atomic pattern> ::= <variable name> | <type name>
    \alt \textbf{(} <pattern> \textbf{)}
    \alt <list pattern>
    \alt <constant>

<list pattern> ::= \textbf{[} <pattern> \textbf{|} <variable name> \textbf{]}
    \alt \textbf{[} <pattern> \textbf{]}
    \alt \textbf{[\,\,]}

<constant> ::= <integer> | <boolean> | <float> 
    \alt \textbf{(\,\,)} | <string> | <char>

<tuple expression> ::= <logical or> \textbf{,} <tuple expression>
    \alt <logical or>

<logical or> ::= <logical and> \textbf{and} <logical or>
    \alt <logical and>

<logical and> ::= <expression none 0> \textbf {and} <logical and>
    \alt <expression none 0>

<expression none N> ::= <expression right N> <operator none N>\\ <expression none N>
    \alt <expression right N>

<expression right N> ::= <expression left N> <operator right N>\\ <expression right N>
    \alt <expression left N>

<expression left N> ::= <expression postfix N> <operator left N>\\<expression left N>
    \alt <expression postfix N>

<expression postfix N> ::= <expression prefix N> <operator postfix N>
    \alt <expression prefix N>

<expression prefix 20> ::= <operator prefix 20> <application>
    \alt <application>

<expression prefix N> ::= <operator prefix N> <expression none (N+1)>
    \alt <expression none (N+1)>

<application> ::= <atomic expression> <application>
    \alt <atomic expression>

<atomic expression> ::= <constant>
    \alt \textbf{(} <expression sequence> \textbf{)}
    \alt <list expression>
    \alt <lambda expression>
    \alt \textbf{\`} <operator>
    \alt <identifier>
    \alt <type name>

<lambda expression> ::= \textbf{\{ |} <formal parameters> \textbf{|} <expression sequence> \textbf{\}}

<list expression> ::= \textbf{[} \,\textbf{]}
    \alt \textbf{[} <tuple expression> \textbf{]}
    \alt \textbf{[} <tuple expression> \textbf{|} <logical or> \textbf{]}

\end{grammar}

\section{Semantics}

\section{Type system}

\end{document}


